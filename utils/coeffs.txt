SageMathCellType some Sage code below and press Evaluate.

field_modulus = 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787
desired_curve_order = 52435875175126190479447740508185965837690552500527637822603658699938581184513

Fp = GF(field_modulus)

PARAM_A4 = 0
PARAM_A6 = 4

E = EllipticCurve(Fp, [PARAM_A4, PARAM_A6])
E_order = E.order()
assert E_order % desired_curve_order == 0
assert desired_curve_order.is_prime() is True
E_cofactor = E_order // desired_curve_order
Fr = GF(desired_curve_order)

R.<T> = PolynomialRing(Fp)

# Starting at -1 is an arbitrary choice, could start at 1, where 2 will be the first non-residue
if not Fp(-1).is_square():
    print("# -1 is non-residue")
    non_residue = -1
    F2.<u> = Fp.extension(T^2-non_residue, 'u')
    for j in range(1,4):
        if not (u+j).is_square():
            quadratic_non_residue = u+j
            F12_equation = (T^6 - j)^2 - non_residue
            u_to_w = T^6 - j
            w_to_u = T + j
            break
else:
    print("Unknown")


F12.<w> = Fp.extension(F12_equation)
E12 = EllipticCurve(F12, [0, PARAM_A6])

E2 = EllipticCurve(F2, [0, PARAM_A6*quadratic_non_residue])
is_D_type = False
A_twist = 0
if not (E2.order()/desired_curve_order).is_integer():
    B_twist = PARAM_A6/quadratic_non_residue
    E2 = EllipticCurve(F2, [0, B_twist])
    if not (E2.order()/desired_curve_order).is_integer():
        raise Exception('no twist had appropriate order')
    is_D_type = True
    print("# D type twist")
    F2_PARAM_A4 = PARAM_A4 / quadratic_non_residue
    F2_PARAM_A6 = PARAM_A6 / quadratic_non_residue
else:
    # E2 order is divisible by curve order
    # TODO: get cofactor
    B_twist = PARAM_A6*quadratic_non_residue
    F2_PARAM_A6 = PARAM_A6 * quadratic_non_residue
    F2_PARAM_A4 = PARAM_A4 * quadratic_non_residue
    print('# M type twist')


E2_order = E2.order()
assert E2_order % desired_curve_order == 0
E2_cofactor = E2_order // desired_curve_order



def frobenius_coeffs_powers(modulus, degree, num=None, divisor=None):
    divisor = divisor or degree
    num = num or 1
    tower_modulus = modulus ** degree
    for i in range(num):
        a = i + 1
        q_power = 1
        powers = []
        for j in range(degree):
            powers.append((((a*q_power)-a) // divisor) % tower_modulus)
            q_power *= modulus
        yield powers


def frobenius_coeffs(non_residue, *args, **kwa):
    coeffs = list()
    for i, powers in enumerate(frobenius_coeffs_powers(*args, **kwa)):
        coeffs.append(list())
        for p_i in powers:
            coeffs[i].append( non_residue ** p_i )
    return coeffs


def find_generator(E, F, a6, cofactor, order):
    for x in range(1, 10**3):
        x = F(x)
        y2 = x**3 + a6
        if not y2.is_square():
            continue
        y = y2.sqrt()
        p = cofactor*E(x, y)
        if not p.is_zero() and (order*p).is_zero():
            negy = -p[1]
            if negy < p[1]:
                return -p
            return p


def find_s_t(name, n):
    for s in range(1, 50):
        if n % (2**s) == 0:
            t = n / 2**s
            assert t.is_integer()
            if not ((t-1)/2).is_integer():
                continue
            print name, "s", s
            print name, "t", t
            print name, "t_minus_1_over_2", (t-1)/2
            return s, t


# Finds an R such that R = 2^k, R > N, for the smallest k.
def mont_findR(N, limb_size=64):
    g = 0
    b = 2 ** limb_size
    R = b
    while g != 1:
        R *= b
        if R > N:
            g = gcd(R, N)
    return R


def print_field(name, q, F):
    print name, 'modulus', q
    print name, 'num_bits', ceil(log(q,2))
    print name, 'euler', (q-1)//2
    s, t = find_s_t(name, q-1)
    print name, 'multiplicative_generator', F.vector_space()(F.multiplicative_generator())
    gen = F.gen()
    for i in range(0, 100): #for i in range(-1, -100, -1):
        i = gen+i
        if not i.is_square():
            i_to_t = i**t
            print name, 'nqr', F.vector_space()(i)
            print name, 'nqr_to_t', F.vector_space()(i_to_t)
            break
    print ""


def print_R(name, q, nbits):
    R = mont_findR(q, nbits)
    print name, "R (%d-bit)" % (nbits,), R
    print name, "Rcubed (%d-bit)" % (nbits,), (R**2) % q
    print name, "Rsquared (%d-bit)" % (nbits,), (R**3) % q    
    print name, "inv (%d-bit)" % (nbits,), hex((-q^-1) % 2**nbits)


G1 = find_generator(E, Fp, PARAM_A6, E_cofactor, desired_curve_order)
print 'bls12_381 G1_zero', E(0)
print 'bls12_381 G1_one', [Fp.vector_space()(_) for _ in G1]
print ""

G2 = find_generator(E2, F2, F2_PARAM_A6, E2_cofactor, desired_curve_order)
print 'bls12_381_G2_zero', E2(0)
print 'bls12_381 G2_one', [F2.vector_space()(_) for _ in G2]
print ""

print_field('bls12_381_Fq2', field_modulus**2, F2)
fp2_coeffs = frobenius_coeffs(non_residue, field_modulus, 2)
for i, c in enumerate(fp2_coeffs):
    print 'bls12_381_Fq2', 'Frobenius_coeffs_c1[%d]' % (i,), '=', c
print ''


fp6_coeffs = frobenius_coeffs(quadratic_non_residue, field_modulus, 6, 2, 3)
for i, _ in enumerate(fp6_coeffs):
    for j, c in enumerate(_):
        print 'bls12_381_Fq6', 'Frobenius_coeffs_c%d[%d]' % (i + 1, j), '=', F2.vector_space()(c)
print ''

# Fq12 is two 6th degree towers
fp12_coeffs = frobenius_coeffs(quadratic_non_residue, field_modulus, 12, 1, 6)
for i, _ in enumerate(fp12_coeffs):
    for j, c in enumerate(_):
        print 'bls12_381_Fq12', 'Frobenius_coeffs_c%d[%d]' % (i + 1, j), '=', F2.vector_space()(c)
print ''

print_R("bls12_381 Fr", desired_curve_order, 64)
print_R("bls12_381 Fr", desired_curve_order, 32)
print_field('bls12_381_Fr', desired_curve_order, Fr)

print_R("bls12_381 Fq", field_modulus, 64)
print_R("bls12_381 Fq", field_modulus, 32)
print_field('bls12_381_Fq', field_modulus, Fp)
1
field_modulus = 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787
2
desired_curve_order = 52435875175126190479447740508185965837690552500527637822603658699938581184513
3
​
4
Fp = GF(field_modulus)
5
​
6
PARAM_A4 = 0
7
PARAM_A6 = 4
8
​
9
E = EllipticCurve(Fp, [PARAM_A4, PARAM_A6])
10
E_order = E.order()
11
assert E_order % desired_curve_order == 0
12
assert desired_curve_order.is_prime() is True
13
E_cofactor = E_order // desired_curve_order
14
Fr = GF(desired_curve_order)
15
​
16
R.<T> = PolynomialRing(Fp)
17
​
18
# Starting at -1 is an arbitrary choice, could start at 1, where 2 will be the first non-residue
19
if not Fp(-1).is_square():
20
    print("# -1 is non-residue")
21
    non_residue = -1
22
    F2.<u> = Fp.extension(T^2-non_residue, 'u')
23
    for j in range(1,4):
24
        if not (u+j).is_square():
25
            quadratic_non_residue = u+j
26
            F12_equation = (T^6 - j)^2 - non_residue
27
            u_to_w = T^6 - j
28
            w_to_u = T + j
29
            break
30
else:
31
    print("Unknown")
32
​
33
​
34
F12.<w> = Fp.extension(F12_equation)
35
E12 = EllipticCurve(F12, [0, PARAM_A6])
36
​
37
E2 = EllipticCurve(F2, [0, PARAM_A6*quadratic_non_residue])
38
is_D_type = False
39
A_twist = 0
40
if not (E2.order()/desired_curve_order).is_integer():
41
    B_twist = PARAM_A6/quadratic_non_residue
42
    E2 = EllipticCurve(F2, [0, B_twist])
43
    if not (E2.order()/desired_curve_order).is_integer():
44
        raise Exception('no twist had appropriate order')
45
    is_D_type = True
46
    print("# D type twist")
47
    F2_PARAM_A4 = PARAM_A4 / quadratic_non_residue
48
    F2_PARAM_A6 = PARAM_A6 / quadratic_non_residue
49
else:
50
    # E2 order is divisible by curve order
51
    # TODO: get cofactor
52
    B_twist = PARAM_A6*quadratic_non_residue
53
    F2_PARAM_A6 = PARAM_A6 * quadratic_non_residue
54
    F2_PARAM_A4 = PARAM_A4 * quadratic_non_residue
55
    print('# M type twist')
56
​
57
​
58
E2_order = E2.order()
59
assert E2_order % desired_curve_order == 0
60
E2_cofactor = E2_order // desired_curve_order
61
​
62
​
63
​
64
def frobenius_coeffs_powers(modulus, degree, num=None, divisor=None):
65
    divisor = divisor or degree
66
    num = num or 1
67
    tower_modulus = modulus ** degree
68
    for i in range(num):
69
        a = i + 1
70
        q_power = 1
71
        powers = []
72
        for j in range(degree):
73
            powers.append((((a*q_power)-a) // divisor) % tower_modulus)
74
            q_power *= modulus
75
        yield powers
76
​
77
​
78
def frobenius_coeffs(non_residue, *args, **kwa):
79
    coeffs = list()
80
    for i, powers in enumerate(frobenius_coeffs_powers(*args, **kwa)):
81
        coeffs.append(list())
82
        for p_i in powers:
83
            coeffs[i].append( non_residue ** p_i )
84
    return coeffs
85
​
86
​
87
def find_generator(E, F, a6, cofactor, order):
88
    for x in range(1, 10**3):
89
        x = F(x)
90
        y2 = x**3 + a6
91
        if not y2.is_square():
92
            continue
93
        y = y2.sqrt()
94
        p = cofactor*E(x, y)
95
        if not p.is_zero() and (order*p).is_zero():
96
            negy = -p[1]
97
            if negy < p[1]:
98
                return -p
99
            return p
100
​
101
​
102
def find_s_t(name, n):
103
    for s in range(1, 50):
104
        if n % (2**s) == 0:
105
            t = n / 2**s
106
            assert t.is_integer()
107
            if not ((t-1)/2).is_integer():
108
                continue
109
            print (name, "s", s)
110
            print (name, "t", t)
111
            print (name, "t_minus_1_over_2", (t-1)/2)
112
            return s, t
113
​
114
​
115
# Finds an R such that R = 2^k, R > N, for the smallest k.
116
def mont_findR(N, limb_size=64):
117
    g = 0
118
    b = 2 ** limb_size
119
    R = b
120
    while g != 1:
121
        R *= b
122
        if R > N:
123
            g = gcd(R, N)
124
    return R
125
​
126
​
127
def print_field(name, q, F):
128
    print( name, 'modulus', q)
129
    print (name, 'num_bits', ceil(log(q,2)))
130
    print( name, 'euler', (q-1)//2)
131
    s, t = find_s_t(name, q-1)
132
    print (name, 'multiplicative_generator', F.vector_space()(F.multiplicative_generator()))
133
    gen = F.gen()
134
    for i in range(0, 100): #for i in range(-1, -100, -1):
135
        i = gen+i
136
        if not i.is_square():
137
            i_to_t = i**t
138
            print (name, 'nqr', F.vector_space()(i))
139
            print (name, 'nqr_to_t', F.vector_space()(i_to_t))
140
            break
141
    print ("")
142
​
143
​
144
def print_R(name, q, nbits):
145
    R = mont_findR(q, nbits)
146
    print (name, "R (%d-bit)" % (nbits,), R)
147
    print (name, "Rcubed (%d-bit)" % (nbits,), (R**2) % q)
148
    print (name, "Rsquared (%d-bit)" % (nbits,), (R**3) % q    )
149
    print (name, "inv (%d-bit)" % (nbits,), hex((-q^-1) % 2**nbits))
150
​
151
​
152
G1 = find_generator(E, Fp, PARAM_A6, E_cofactor, desired_curve_order)
153
print ('bls12_381 G1_zero', E(0))
154
print ('bls12_381 G1_one', [Fp.vector_space()(_) for _ in G1])
155
print ("")
156
​
157
G2 = find_generator(E2, F2, F2_PARAM_A6, E2_cofactor, desired_curve_order)
158
print  ('bls12_381_G2_zero', E2(0))
159
print ('bls12_381 G2_one', [F2.vector_space()(_) for _ in G2])
160
print ("")
161
​
162
print_field('bls12_381_Fq2', field_modulus**2, F2)
163
fp2_coeffs = frobenius_coeffs(non_residue, field_modulus, 2)
164
for i, c in enumerate(fp2_coeffs):
165
    print ('bls12_381_Fq2', 'Frobenius_coeffs_c1[%d]' % (i,), '=', c)
166
print ('')
167
​
168
​
169
fp6_coeffs = frobenius_coeffs(quadratic_non_residue, field_modulus, 6, 2, 3)
170
for i, _ in enumerate(fp6_coeffs):
171
    for j, c in enumerate(_):
172
        print ('bls12_381_Fq6', 'Frobenius_coeffs_c%d[%d]' % (i + 1, j), '=', F2.vector_space()(c))
173
print ('')
174
​
175
# Fq12 is two 6th degree towers
176
fp12_coeffs = frobenius_coeffs(quadratic_non_residue, field_modulus, 12, 1, 6)
177
for i, _ in enumerate(fp12_coeffs):
178
    for j, c in enumerate(_):
179
        print ('bls12_381_Fq12', 'Frobenius_coeffs_c%d[%d]' % (i + 1, j), '=', F2.vector_space()(c))
180
print ('')
181
​
182
print_R("bls12_381 Fr", desired_curve_order, 64)
183
print_R("bls12_381 Fr", desired_curve_order, 32)
184
print_field('bls12_381_Fr', desired_curve_order, Fr)
185
​
186
print_R("bls12_381 Fq", field_modulus, 64)
187
print_R("bls12_381 Fq", field_modulus, 32)
188
print_field('bls12_381_Fq', field_modulus, Fp)
Language: 
Sage
Share
# -1 is non-residue
# M type twist
bls12_381 G1_zero (0 : 1 : 0)
/home/sc_serv/sage/local/var/lib/sage/venv-python3.9.9/lib/python3.9/site-packages/sage/categories/fields.py:533: DeprecationWarning: The default value for map will be changing to True.  To keep the current behavior, explicitly pass map=False.
See https://trac.sagemath.org/28481 for details.
  return self.free_module(*args, **kwds)
bls12_381 G1_one [(3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507), (1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569), (1)]

bls12_381_G2_zero (0 : 1 : 0)
bls12_381 G2_one [(352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160, 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758), (1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905, 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582), (1, 0)]

bls12_381_Fq2 modulus 16019282247729705411943748644318972617695120099330552659862384536985976748491357143400656079302193429974954385540170730531103884539706905936200202421036435811093013034271812758016407969496331661418541023677774899971425993489485369
bls12_381_Fq2 num_bits 762
bls12_381_Fq2 euler 8009641123864852705971874322159486308847560049665276329931192268492988374245678571700328039651096714987477192770085365265551942269853452968100101210518217905546506517135906379008203984748165830709270511838887449985712996744742684
bls12_381_Fq2 s 3
bls12_381_Fq2 t 2002410280966213176492968580539871577211890012416319082482798067123247093561419642925082009912774178746869298192521341316387985567463363242025025302629554476386626629283976594752050996187041457677317627959721862496428249186185671
bls12_381_Fq2 t_minus_1_over_2 1001205140483106588246484290269935788605945006208159541241399033561623546780709821462541004956387089373434649096260670658193992783731681621012512651314777238193313314641988297376025498093520728838658813979860931248214124593092835
bls12_381_Fq2 multiplicative_generator (2, 1)
bls12_381_Fq2 nqr (1, 1)
bls12_381_Fq2 nqr_to_t (1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257, 2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530)

bls12_381_Fq2 Frobenius_coeffs_c1[0] = [1, -1]

bls12_381_Fq6 Frobenius_coeffs_c1[0] = (1, 0)
bls12_381_Fq6 Frobenius_coeffs_c1[1] = (0, 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436)
bls12_381_Fq6 Frobenius_coeffs_c1[2] = (793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350, 0)
bls12_381_Fq6 Frobenius_coeffs_c1[3] = (0, 1)
bls12_381_Fq6 Frobenius_coeffs_c1[4] = (4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436, 0)
bls12_381_Fq6 Frobenius_coeffs_c1[5] = (0, 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350)
bls12_381_Fq6 Frobenius_coeffs_c2[0] = (1, 0)
bls12_381_Fq6 Frobenius_coeffs_c2[1] = (4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437, 0)
bls12_381_Fq6 Frobenius_coeffs_c2[2] = (4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436, 0)
bls12_381_Fq6 Frobenius_coeffs_c2[3] = (4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786, 0)
bls12_381_Fq6 Frobenius_coeffs_c2[4] = (793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350, 0)
bls12_381_Fq6 Frobenius_coeffs_c2[5] = (793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351, 0)

bls12_381_Fq12 Frobenius_coeffs_c1[0] = (1, 0)
bls12_381_Fq12 Frobenius_coeffs_c1[1] = (3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760, 151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027)
bls12_381_Fq12 Frobenius_coeffs_c1[2] = (793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351, 0)
bls12_381_Fq12 Frobenius_coeffs_c1[3] = (2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530, 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257)
bls12_381_Fq12 Frobenius_coeffs_c1[4] = (793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350, 0)
bls12_381_Fq12 Frobenius_coeffs_c1[5] = (3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557, 877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230)
bls12_381_Fq12 Frobenius_coeffs_c1[6] = (4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786, 0)
bls12_381_Fq12 Frobenius_coeffs_c1[7] = (151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027, 3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760)
bls12_381_Fq12 Frobenius_coeffs_c1[8] = (4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436, 0)
bls12_381_Fq12 Frobenius_coeffs_c1[9] = (1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257, 2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530)
bls12_381_Fq12 Frobenius_coeffs_c1[10] = (4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437, 0)
bls12_381_Fq12 Frobenius_coeffs_c1[11] = (877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230, 3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557)

bls12_381 Fr R (64-bit) 115792089237316195423570985008687907853269984665640564039457584007913129639936
bls12_381 Fr Rcubed (64-bit) 3294906474794265442129797520630710739278575682199800681788903916070560242797
bls12_381 Fr Rsquared (64-bit) 49829253988540319354550742249276084460127446355315915089527227471280320770991
bls12_381 Fr inv (64-bit) 0xfffffffeffffffff
bls12_381 Fr R (32-bit) 115792089237316195423570985008687907853269984665640564039457584007913129639936
bls12_381 Fr Rcubed (32-bit) 3294906474794265442129797520630710739278575682199800681788903916070560242797
bls12_381 Fr Rsquared (32-bit) 49829253988540319354550742249276084460127446355315915089527227471280320770991
bls12_381 Fr inv (32-bit) 0xffffffff
bls12_381_Fr modulus 52435875175126190479447740508185965837690552500527637822603658699938581184513
bls12_381_Fr num_bits 255
bls12_381_Fr euler 26217937587563095239723870254092982918845276250263818911301829349969290592256
bls12_381_Fr s 32
bls12_381_Fr t 12208678567578594777604504606729831043093128246378069236549469339647
bls12_381_Fr t_minus_1_over_2 6104339283789297388802252303364915521546564123189034618274734669823
bls12_381_Fr multiplicative_generator (7)
bls12_381_Fr nqr (5)
bls12_381_Fr nqr_to_t (937917089079007706106976984802249742464848817460758522850752807661925904159)

bls12_381 Fq R (64-bit) 39402006196394479212279040100143613805079739270465446667948293404245721771497210611414266254884915640806627990306816
bls12_381 Fq Rcubed (64-bit) 2708263910654730174793787626328176511836455197166317677006154293982164122222515399004018013397331347120527951271750
bls12_381 Fq Rsquared (64-bit) 1639067542774625894236716575548084905938753837211594095883637014582201460755008380976950835174037649440777609978336
bls12_381 Fq inv (64-bit) 0x89f3fffcfffcfffd
bls12_381 Fq R (32-bit) 39402006196394479212279040100143613805079739270465446667948293404245721771497210611414266254884915640806627990306816
bls12_381 Fq Rcubed (32-bit) 2708263910654730174793787626328176511836455197166317677006154293982164122222515399004018013397331347120527951271750
bls12_381 Fq Rsquared (32-bit) 1639067542774625894236716575548084905938753837211594095883637014582201460755008380976950835174037649440777609978336
bls12_381 Fq inv (32-bit) 0xfffcfffd
bls12_381_Fq modulus 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787
bls12_381_Fq num_bits 381
bls12_381_Fq euler 2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279893
bls12_381_Fq s 1
bls12_381_Fq t 2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279893
bls12_381_Fq t_minus_1_over_2 1000602388805416848354447456433976039139220704984751971333014534031007912622709466110671907282253916009473568139946
bls12_381_Fq multiplicative_generator (2)
bls12_381_Fq nqr (2)
bls12_381_Fq nqr_to_t (4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786)

Help | Powered by SageMath
About SageMathCell
About
SageMathCell project is an easy-to-use web interface to a free open-source mathematics software system SageMath. You can help SageMath by becoming a .

It allows embedding Sage computations into any webpage: check out our short instructions, a comprehensive description of capabilities, or Notebook Player to convert Jupyter notebooks into dynamic HTML pages!

Resources for your computation are provided by SageMath, Inc.. You can also set up your own server.

General Questions on Using Sage
There are a lot of resources available to help you use Sage. In particular, you may ask questions on sage-support discussion group or ask.sagemath.org website.

Problems and Suggestions
Unfortunately, we can no longer allow user code in cells to freely access Internet. See this discussion for details.

If you experience any problems or have suggestions on improving this service (e.g., you want a package installed), please email Andrey Novoseltsev.

SageMathCell is expected to work with any modern browser and without any downtime.

CoCalc
Need more power and flexibility but still prefer to avoid your own installation of Sage? CoCalc will allow you to work with multiple persistent worksheets in Sage, IPython, LaTeX, and much, much more!